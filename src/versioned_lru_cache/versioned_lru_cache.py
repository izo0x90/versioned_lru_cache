# coding: utf-8
"""
SOME DOCS TO GO HERE
"""
# TODO: Add further doc strings

from __future__ import annotations
import functools
import time
from typing import Any, Callable, Tuple, TypeVar, ParamSpec, Optional
from typing_extensions import Protocol

_SESSION_CONTEXT_CACHE_MAP_NAME = "lru_cache_versions"

CacheVersionId = Tuple[str, int]
CacheVersionFunc = Callable[..., str]
ToBeCashedFuncPrams = ParamSpec("ToBeCashedFuncPrams")
ToBeCashedFuncReturnVal = TypeVar("ToBeCashedFuncReturnVal")


class ProxyToMutableMapping(Protocol):
    """
    NOTE: Whatever the mutable mapping that stores the cache version ids for the
    duration of the session (ex. request) should not be pointed to directly, but rather
    by a proxy that can provide us access to a new "session context" every time a
    "session" restarts.

    This is due to the fact that the ref. to this "proxy" object will be
    composed/ stored when the decorator factory is building the wrapper function.

    schema: global_session_obj
             .(key: _SESSION_CONTEXT_CACHE_MAP_NAME, val: MutableMapping)
             .(key: module_name, val: MutableMapping)
             .(key: function_name, val: str(version_id))
    """

    def get(self, key: Any, default: Optional[Any]) -> Any:
        ...

    def setdefault(self, key: Any, default: Any) -> Any:
        ...


def make_cache_version_id_with_time_to_live(
    version_id: str, ttl_seconds: int = 60 * 60
) -> CacheVersionId:
    """
    Used to generate the actual version param passed to lru_cache, appending a time
    "hash" to the version generated by the invalidation function. This allows for
    cached values to get invalidated after the desired time period has passed
    regardless of version.
    """
    ttl_hash = round(time.time() / ttl_seconds)
    return (version_id, ttl_hash)


def store_lru_cache_version_on_session_context(
    proxy_to_session_context_object: ProxyToMutableMapping,
    module_name: str,
    function_name: str,
    version_id: str,
) -> None:
    proxy_to_session_context_object.setdefault(
        _SESSION_CONTEXT_CACHE_MAP_NAME, {}
    ).setdefault(module_name, {})[function_name] = version_id


def get_lru_cache_version_on_session_context(
    proxy_to_session_context_object: ProxyToMutableMapping,
    module_name: str,
    function_name: str,
) -> Optional[str]:
    """
    We are enforcing the invariant about the cache version being a str with the
    return required of the versioning function
    """
    return (  # type: ignore[no-any-return]
        proxy_to_session_context_object.get(_SESSION_CONTEXT_CACHE_MAP_NAME, {})
        .get(module_name, {})
        .get(function_name)
    )


# #### Decorators
def versioned_lru_cache_with_ttl(
    *,
    proxy_to_session_context_object: ProxyToMutableMapping,
    generate_version_func: CacheVersionFunc,
    module_name: str,
    cache_max_size: int = 1,
    time_to_live_seconds: int = 60 * 60,  # 1 hour
    no_history_events_default_version: str = "-1",
) -> Callable:
    """
    Decorator factory.

    Args:
        proxy_to_session_context_object: ProxyToMutableMapping,
        generate_version_func: CacheVersionFunc,
        module_name: str,
        cache_max_size: int = 1,
        time_to_live_seconds: int = 60 * 60,  # 1 hour
        no_history_events_default_version: str = "-1"

    Returns:
        Decorator that will setup/ generate the versioned cache wrapper.
    """

    def decorator(
        to_be_cached_func: Callable[ToBeCashedFuncPrams, ToBeCashedFuncReturnVal]
    ) -> Callable:
        """ """

        def with_version(
            *args: Any, _lru_cache_version: CacheVersionId, **kwargs: Any
        ) -> Any:
            # the _lru_cache_version arg is used to force functools.lru_cache to store
            # and retrieve versioned return results, we want to remove before passing
            # call args to actual to_be_cached_func to avoid blowing up if
            # func signature can not handle or other unintended side-effects
            # del kwargs["_lru_cache_version"]
            _lru_cache_version
            return to_be_cached_func(*args, **kwargs)

        to_be_cached_func_name = getattr(to_be_cached_func, "__name__")
        with_version = functools.lru_cache(maxsize=cache_max_size)(with_version)

        @functools.wraps(to_be_cached_func)
        def invalidate_or_return_cached(
            *args: ToBeCashedFuncPrams.args, **kwargs: ToBeCashedFuncPrams.kwargs
        ) -> Any:
            """
            This wrapper around the to_be_cached_func is responsible for returning
            the appropriate versioned cached value for the to_be_cahed_func
            if available.
            """
            if "_lru_cache_version" in kwargs:  # type: ignore[attr-defined]
                raise NameError(
                    'Argument "_lru_cache_version" must be reserved for \
                    invalidate_or_return_cached wrapper func, wrapped function can \
                    NOT have a argument with that name'
                )

            # Look for already calculated cache version id on "session context object"
            cache_version_id = get_lru_cache_version_on_session_context(
                proxy_to_session_context_object, module_name, to_be_cached_func_name
            )

            # On the first call within a "session" we need to run the version
            # calculate function and store the cache version id on the
            # "session context", this way further call to the cached function can
            # simply return the cached return value of the function
            if not cache_version_id:
                cache_version_id = (
                    generate_version_func(*args, **kwargs)
                    or no_history_events_default_version
                )

                store_lru_cache_version_on_session_context(
                    proxy_to_session_context_object,
                    module_name,
                    to_be_cached_func_name,
                    cache_version_id,
                )

            # If the time to live has "expired" version should be "ticked" up so that
            # cache can be invalidated
            cache_version_id_with_ttl = make_cache_version_id_with_time_to_live(
                cache_version_id, time_to_live_seconds
            )

            # If the version changed either because the version generate function shows
            # underlaying data has changed or time to live has expired cache should be
            # invalidated and function needs to "redo" the work and re-cache so that
            # stale results are not returned
            return with_version(
                *args, **kwargs, _lru_cache_version=cache_version_id_with_ttl
            )

        return invalidate_or_return_cached

    return decorator
